/***************************************************************************
    qgsmapserverexport.cpp - Export QGIS MapCanvas to MapServer
     --------------------------------------
    Date                 : 8-Nov-2003
    Copyright            : (C) 2003 by Gary E.Sherman
    email                : sherman at mrcc.com
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
/* $Id$ */

 #include <iostream>
 #include <fstream>
 #include <qfiledialog.h>
 #include <qfileinfo.h>
 #include <qmessagebox.h>
 #include <qcolor.h>
 #include <qregexp.h>
 #include "qgsmaplayer.h"
 #ifdef POSTGRESQL
 #include "qgsdatabaselayer.h"
 #endif
 #include "qgsshapefilelayer.h"
#include "qgsmapcanvas.h"
#include "qgsrect.h"
#include "qgsmapserverexport.h"
#include "qgis.h"

QgsMapServerExport::QgsMapServerExport(QgsMapCanvas *_map, int _action) : map(_map), action(_action)

{
}


QgsMapServerExport::~QgsMapServerExport()
{
}
QString QgsMapServerExport::baseName(){
QFileInfo fi(fullPath);
return fi.baseName(true);
}
bool QgsMapServerExport::write(){
	if(fullPath.isEmpty()){
		selectFileName();
	}
	//QMessageBox::information(0,"Full Path",fullPath);
	int okToSave = 0;
	if(QFile::exists(fullPath) && (action == SAVEAS)){
		okToSave = QMessageBox::warning(0,"Overwrite File?",fullPath + " exists. \nDo you want to overwrite it?", "Yes", "No");
	}
	if(okToSave == 0){
	// write the project information to the selected file
		writeMapFile();
		return true;
	}else{
		return false;
		}
}

//Read map server file to create a QGIS view
//TODO - implement this function!
bool QgsMapServerExport::read(){
	
	return true;
}

QString QgsMapServerExport::selectFileName(){
if(action == SAVE && fullPath.isEmpty()){
	action = SAVEAS;
	}
switch(action){
	case OPEN:
	fullPath = QFileDialog::getOpenFileName("./", "MapServer files (*.map)", 0,  0, "Choose a file to open" );
  
	break;
	case SAVEAS:
		fullPath = QFileDialog::getSaveFileName("./", "MapServer files (*.map)", 0,  0, "Choose a filename  to save" );
	break;
	}
	return fullPath;
}
void QgsMapServerExport::setFileName(QString fn){
	fullPath = fn;
	}
QString QgsMapServerExport::fullPathName(){
	return fullPath;
	}
void QgsMapServerExport::writeMapFile(){
	// write the map file, making massive assumptions about default values
	std::ofstream mapFile(fullPath);
	if(!mapFile.fail()){
		// header
		mapFile << "#\n# Map file generated by QGIS\n#" << std::endl;
		mapFile << "# Edit this file to customize for your interface" << std::endl;
		mapFile << "# Not all sections are complete. See comments for details." << std::endl;
		
		mapFile << "NAME QGIS_Map" << std::endl; //TODO - use the project name is set
		mapFile << "STATUS ON" << std::endl;
		mapFile << "\n# Change size as desired" << std::endl;
		mapFile << "SIZE 600 600" << std::endl;
		// web interface definition - this is minimal!
		mapFile << "#" << std::endl;
		mapFile << "# Start of web interface definition. Only the TEMPLATE parameter" << std::endl;
		mapFile << "# must be specified to display a map. See Mapserver documentation" << std::endl;
		mapFile << "#" << std::endl;
		mapFile << "WEB" << std::endl;
		mapFile << "  #HEADER" << std::endl;
		mapFile << "  TEMPLATE <html template file name>" << std::endl;
		mapFile << "  #FOOTER" << std::endl;
		mapFile << "  #MINSCALE" << std::endl;
		mapFile << "  #MAXSCALE" << std::endl;
		mapFile << "END" << std::endl;
		// extent
		mapFile << "\n# Extent based on full extent of QGIS view" << std::endl;
		mapFile << "EXTENT ";
		QgsRect extent = map->extent();
		mapFile << extent.xMin() << " " << extent.yMin() << " ";
		mapFile << extent.xMax() << " " << extent.yMax() << std::endl;
		// units
		mapFile << "UNITS METERS" << std::endl;
		// image info
		mapFile << "IMAGECOLOR 255 255 255" << std::endl;
		mapFile << "IMAGETYPE PNG" << std::endl;
		// projection information TODO: support projections :)
		mapFile << "# Projection definition" << std::endl;
		// TODO - write WEB section
		
		// layer definitions 
		for(int i = 0; i < map->layerCount(); i++){
			bool isPolygon =false;
			bool isLine = false;
			QgsMapLayer *lyr = map->getZpos(i);
			mapFile << "LAYER" << std::endl;
			QString name = lyr->name().lower();
			// MapServer NAME must be < 20 char and unique
			name.replace(QRegExp(" "),"_");
			name.replace(QRegExp("\\."),"_");
			name.replace(QRegExp("\\("), "_");
			name.replace(QRegExp("\\)"), "_");
			mapFile << "  NAME " << name << std::endl;
			// feature type
			mapFile << "  TYPE "; 
			switch (lyr->featureType()) {
				case QGis::WKBPoint:
				case QGis::WKBMultiPoint:
                  mapFile << "POINT";
                  break;
				case QGis::WKBLineString:
				  case QGis::WKBMultiLineString:
                  mapFile << "LINE";
				  isLine = true;
                  break;
				case QGis::WKBPolygon:
				case QGis::WKBMultiPolygon:
                 mapFile << "POLYGON";
				 isPolygon = true;
                  break;
			}
			mapFile << std::endl;
			
			// set visibility (STATUS)
			mapFile << "  STATUS ";
			if(lyr->visible()){
				mapFile << "ON";
			}else{
				mapFile << "OFF";
			}
			mapFile << std::endl;
			
			// data source (DATA)
			// Data source spec depends on layer type
			switch(lyr->type()){
				case QgsMapLayer::VECTOR:
					mapFile << "  DATA " << lyr->source() << std::endl;
					break;
				case QgsMapLayer::DATABASE:
					QgsDatabaseLayer *dblyr = (QgsDatabaseLayer *)lyr;
					mapFile << "  CONNECTION \"" << lyr->source() << "\"" << std::endl;
					mapFile << "  CONNECTIONTYPE postgis" << std::endl;
					mapFile << "  DATA \"" << dblyr->geometryColumnName() <<
						" from " << dblyr->geometryTableName() << "\"" << std::endl;
					break;
			}
			// create a simple class entry based on layer color
			QgsSymbol *sym = lyr->symbol();
			mapFile << "  CLASS" << std::endl;
			QgsLegend *lgd = map->getLegend();
			//QListViewItem *li = lgd->currentItem();
            //    return li->text(0);
			mapFile << "    NAME \"" << lyr->name() << "\"" << std::endl;
			mapFile << "    # TEMPLATE" << std::endl;
			QColor fillColor = sym->fillColor();
			if(!isLine){
			mapFile << "    COLOR " << fillColor.red() << " " <<
				fillColor.green() << " " << fillColor.blue() << std::endl;
			}
			if(isPolygon || isLine){
				QColor outlineColor = sym->color();
				mapFile << "    OUTLINECOLOR " << outlineColor.red() << " "	
					<< outlineColor.green() << " " << outlineColor.blue() 
					<< std::endl;
			}
			mapFile << "  END" << std::endl;
			mapFile << "END" << std::endl;
		}
		mapFile << "END # Map File";
		mapFile.close();
	}else{
	}
}
